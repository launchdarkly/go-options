package test

// Code generated by github.com/launchdarkly/go-options.  DO NOT EDIT.

import (
	"net/url"
	"time"
	time2 "time"
)

import "github.com/google/go-cmp/cmp"

type ApplyOptionFunc func(c *config) error

func (f ApplyOptionFunc) apply(c *config) error {
	return f(c)
}

func newConfig(options ...Option) (config, error) {
	var c config
	err := applyConfigOptions(&c, options...)
	return c, err
}

func applyConfigOptions(c *config, options ...Option) error {
	c.myIntWithDefault = 1
	c.myFloatWithDefault = 1.23
	c.myStringWithDefault = `default string`
	c.myStructWithDefault.a = 1
	for _, o := range options {
		if err := o.apply(c); err != nil {
			return err
		}
	}
	return nil
}

type Option interface {
	apply(*config) error
}

type optionMyIntImpl struct {
	o int
}

func (o optionMyIntImpl) apply(c *config) error {
	c.myInt = o.o
	return nil
}

func (o optionMyIntImpl) Equal(v optionMyIntImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func OptionMyInt(o int) Option {
	return optionMyIntImpl{
		o: o,
	}
}

type optionMyIntWithDefaultImpl struct {
	o int
}

func (o optionMyIntWithDefaultImpl) apply(c *config) error {
	c.myIntWithDefault = o.o
	return nil
}

func (o optionMyIntWithDefaultImpl) Equal(v optionMyIntWithDefaultImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func OptionMyIntWithDefault(o int) Option {
	return optionMyIntWithDefaultImpl{
		o: o,
	}
}

type optionYourIntImpl struct {
	o int
}

func (o optionYourIntImpl) apply(c *config) error {
	c.myRenamedInt = o.o
	return nil
}

func (o optionYourIntImpl) Equal(v optionYourIntImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func OptionYourInt(o int) Option {
	return optionYourIntImpl{
		o: o,
	}
}

type optionMyDocumentedIntImpl struct {
	o int
}

func (o optionMyDocumentedIntImpl) apply(c *config) error {
	c.myDocumentedInt = o.o
	return nil
}

func (o optionMyDocumentedIntImpl) Equal(v optionMyDocumentedIntImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

// OptionMyDocumentedInt does something
func OptionMyDocumentedInt(o int) Option {
	return optionMyDocumentedIntImpl{
		o: o,
	}
}

type optionMyCommentedIntImpl struct {
	o int
}

func (o optionMyCommentedIntImpl) apply(c *config) error {
	c.myCommentedInt = o.o
	return nil
}

func (o optionMyCommentedIntImpl) Equal(v optionMyCommentedIntImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

// OptionMyCommentedInt for some reason
func OptionMyCommentedInt(o int) Option {
	return optionMyCommentedIntImpl{
		o: o,
	}
}

type optionMyDocAndCommentIntImpl struct {
	o int
}

func (o optionMyDocAndCommentIntImpl) apply(c *config) error {
	c.myDocAndCommentInt = o.o
	return nil
}

func (o optionMyDocAndCommentIntImpl) Equal(v optionMyDocAndCommentIntImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

// OptionMyDocAndCommentInt does something else
// for some other reason
func OptionMyDocAndCommentInt(o int) Option {
	return optionMyDocAndCommentIntImpl{
		o: o,
	}
}

type optionMyFloatImpl struct {
	o float64
}

func (o optionMyFloatImpl) apply(c *config) error {
	c.myFloat = o.o
	return nil
}

func (o optionMyFloatImpl) Equal(v optionMyFloatImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

// OptionMyFloat takes a float
// really a float
func OptionMyFloat(o float64) Option {
	return optionMyFloatImpl{
		o: o,
	}
}

type optionMyFloatWithDefaultImpl struct {
	o float64
}

func (o optionMyFloatWithDefaultImpl) apply(c *config) error {
	c.myFloatWithDefault = o.o
	return nil
}

func (o optionMyFloatWithDefaultImpl) Equal(v optionMyFloatWithDefaultImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func OptionMyFloatWithDefault(o float64) Option {
	return optionMyFloatWithDefaultImpl{
		o: o,
	}
}

type optionMyStringImpl struct {
	o string
}

func (o optionMyStringImpl) apply(c *config) error {
	c.myString = o.o
	return nil
}

func (o optionMyStringImpl) Equal(v optionMyStringImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func OptionMyString(o string) Option {
	return optionMyStringImpl{
		o: o,
	}
}

type optionMyStringWithDefaultImpl struct {
	o string
}

func (o optionMyStringWithDefaultImpl) apply(c *config) error {
	c.myStringWithDefault = o.o
	return nil
}

func (o optionMyStringWithDefaultImpl) Equal(v optionMyStringWithDefaultImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func OptionMyStringWithDefault(o string) Option {
	return optionMyStringWithDefaultImpl{
		o: o,
	}
}

type optionMyFuncImpl struct {
	o func() int
}

func (o optionMyFuncImpl) apply(c *config) error {
	c.myFunc = o.o
	return nil
}

func (o optionMyFuncImpl) Equal(v optionMyFuncImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func OptionMyFunc(o func() int) Option {
	return optionMyFuncImpl{
		o: o,
	}
}

type optionMyIntPointerImpl struct {
	o *int
}

func (o optionMyIntPointerImpl) apply(c *config) error {
	c.myIntPointer = o.o
	return nil
}

func (o optionMyIntPointerImpl) Equal(v optionMyIntPointerImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func OptionMyIntPointer(o *int) Option {
	return optionMyIntPointerImpl{
		o: o,
	}
}

type optionMyInterfaceImpl struct {
	o interface{}
}

func (o optionMyInterfaceImpl) apply(c *config) error {
	c.myInterface = o.o
	return nil
}

func (o optionMyInterfaceImpl) Equal(v optionMyInterfaceImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func OptionMyInterface(o interface{}) Option {
	return optionMyInterfaceImpl{
		o: o,
	}
}

type optionMyURLImpl struct {
	o url.URL
}

func (o optionMyURLImpl) apply(c *config) error {
	c.myURL = o.o
	return nil
}

func (o optionMyURLImpl) Equal(v optionMyURLImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

// OptionMyURL types requiring imports
func OptionMyURL(o url.URL) Option {
	return optionMyURLImpl{
		o: o,
	}
}

type optionMyDurationImpl struct {
	o time.Duration
}

func (o optionMyDurationImpl) apply(c *config) error {
	c.myDuration = o.o
	return nil
}

func (o optionMyDurationImpl) Equal(v optionMyDurationImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func OptionMyDuration(o time.Duration) Option {
	return optionMyDurationImpl{
		o: o,
	}
}

type optionMyDuration2Impl struct {
	o time2.Duration
}

func (o optionMyDuration2Impl) apply(c *config) error {
	c.myDuration2 = o.o
	return nil
}

func (o optionMyDuration2Impl) Equal(v optionMyDuration2Impl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func OptionMyDuration2(o time2.Duration) Option {
	return optionMyDuration2Impl{
		o: o,
	}
}

type optionMyStructImpl struct {
	a int
	b int
}

func (o optionMyStructImpl) apply(c *config) error {
	c.myStruct.a = o.a
	c.myStruct.b = o.b
	return nil
}

func (o optionMyStructImpl) Equal(v optionMyStructImpl) bool {
	switch {
	case !cmp.Equal(o.a, v.a):
		return false
	case !cmp.Equal(o.b, v.b):
		return false
	}
	return true
}

func OptionMyStruct(a int, b int) Option {
	return optionMyStructImpl{
		a: a,
		b: b,
	}
}

type optionMyStructWithDefaultImpl struct {
	a int
}

func (o optionMyStructWithDefaultImpl) apply(c *config) error {
	c.myStructWithDefault.a = o.a
	return nil
}

func (o optionMyStructWithDefaultImpl) Equal(v optionMyStructWithDefaultImpl) bool {
	switch {
	case !cmp.Equal(o.a, v.a):
		return false
	}
	return true
}

func OptionMyStructWithDefault(a int) Option {
	return optionMyStructWithDefaultImpl{
		a: a,
	}
}

type optionMyPointerToStructImpl struct {
	a int
	b int
}

func (o optionMyPointerToStructImpl) apply(c *config) error {
	c.myPointerToStruct = new(struct{ a, b int })
	c.myPointerToStruct.a = o.a
	c.myPointerToStruct.b = o.b
	return nil
}

func (o optionMyPointerToStructImpl) Equal(v optionMyPointerToStructImpl) bool {
	switch {
	case !cmp.Equal(o.a, v.a):
		return false
	case !cmp.Equal(o.b, v.b):
		return false
	}
	return true
}

func OptionMyPointerToStruct(a int, b int) Option {
	return optionMyPointerToStructImpl{
		a: a,
		b: b,
	}
}

type optionMyStructWithVariadicSliceImpl struct {
	a int
	b []int
}

func (o optionMyStructWithVariadicSliceImpl) apply(c *config) error {
	c.myStructWithVariadicSlice.a = o.a
	c.myStructWithVariadicSlice.b = o.b
	return nil
}

func (o optionMyStructWithVariadicSliceImpl) Equal(v optionMyStructWithVariadicSliceImpl) bool {
	switch {
	case !cmp.Equal(o.a, v.a):
		return false
	case !cmp.Equal(o.b, v.b):
		return false
	}
	return true
}

func OptionMyStructWithVariadicSlice(a int, b ...int) Option {
	return optionMyStructWithVariadicSliceImpl{
		a: a,
		b: b,
	}
}

type optionMySliceImpl struct {
	o []int
}

func (o optionMySliceImpl) apply(c *config) error {
	c.mySlice = o.o
	return nil
}

func (o optionMySliceImpl) Equal(v optionMySliceImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func OptionMySlice(o ...int) Option {
	return optionMySliceImpl{
		o: o,
	}
}

type optionMyPointerToSliceImpl struct {
	o []int
}

func (o optionMyPointerToSliceImpl) apply(c *config) error {
	c.myPointerToSlice = &o.o
	return nil
}

func (o optionMyPointerToSliceImpl) Equal(v optionMyPointerToSliceImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func OptionMyPointerToSlice(o ...int) Option {
	return optionMyPointerToSliceImpl{
		o: o,
	}
}

type optionYourSliceImpl struct {
	o []int
}

func (o optionYourSliceImpl) apply(c *config) error {
	c.myRenamedSlice = o.o
	return nil
}

func (o optionYourSliceImpl) Equal(v optionYourSliceImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func OptionYourSlice(o ...int) Option {
	return optionYourSliceImpl{
		o: o,
	}
}

type optionMyPointerToIntImpl struct {
	o int
}

func (o optionMyPointerToIntImpl) apply(c *config) error {
	c.myPointerToInt = &o.o
	return nil
}

func (o optionMyPointerToIntImpl) Equal(v optionMyPointerToIntImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func OptionMyPointerToInt(o int) Option {
	return optionMyPointerToIntImpl{
		o: o,
	}
}

type optionYourIntWithPointerImpl struct {
	o int
}

func (o optionYourIntWithPointerImpl) apply(c *config) error {
	c.myPointerToRenamedInt = &o.o
	return nil
}

func (o optionYourIntWithPointerImpl) Equal(v optionYourIntWithPointerImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func OptionYourIntWithPointer(o int) Option {
	return optionYourIntWithPointerImpl{
		o: o,
	}
}

type optionWithJsonTagButNoOptionsImpl struct {
	o string
}

func (o optionWithJsonTagButNoOptionsImpl) apply(c *config) error {
	c.WithJsonTagButNoOptions = o.o
	return nil
}

func (o optionWithJsonTagButNoOptionsImpl) Equal(v optionWithJsonTagButNoOptionsImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

// OptionWithJsonTagButNoOptions ensure we can handle multiple tags
func OptionWithJsonTagButNoOptions(o string) Option {
	return optionWithJsonTagButNoOptionsImpl{
		o: o,
	}
}

type optionGotBothImpl struct {
	o string
}

func (o optionGotBothImpl) apply(c *config) error {
	c.WithBothJsonAndOptions = o.o
	return nil
}

func (o optionGotBothImpl) Equal(v optionGotBothImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func OptionGotBoth(o string) Option {
	return optionGotBothImpl{
		o: o,
	}
}
